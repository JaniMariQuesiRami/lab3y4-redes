// Generated by CoffeeScript 2.7.0
// Universidad del Valle de Guatemala
// Redes
// Laboratorio #3
var Nodo, NodoFlooding

Nodo = class Nodo {
  constructor(name) {
    this.name = name
    this.xmpp_user = ''
    this.neighbors = []
  }

  /**
   * Returns a string representation of the node.
   *
   * @returns {string} - The string representation of the node.
   */
  toString() {
    return `Nodo (${this.name})`
  }

}

/**
 * Represents a node in a network using the flooding algorithm.
 * Extends the base Nodo class.
 */
NodoFlooding = class NodoFlooding extends Nodo {
  /**
   * Constructs a NodoFlooding instance.
   *
   * @param {string} identifier - The identifier of the node.
   */
  constructor(identifier) {
    super(identifier)
    this.adjacentNodes = []
    this.routeMap = new Map()
  }

  /**
   * Initiates the flooding algorithm from this node.
   *
   * @param {Array} [ruta=[]] - The current route taken.
   * @param {number} [pesoTotal=0] - The total weight of the current route.
   */
  iniciarInundacion(ruta = [], pesoTotal = 0) {
    var i, len, neighborNode, pesoEnlace, ref, results
    ruta.push(this)
    this.routeMap.set(this.name, [
      {
        ruta: ruta.slice(),
        pesoTotal
      }
    ])
    ref = this.adjacentNodes
    results = []
    for (i = 0, len = ref.length; i < len; i++) {
      ({
        Node: neighborNode,
        Peso: pesoEnlace
      } = ref[i])
      if (!ruta.includes(neighborNode)) {
        results.push(neighborNode.procesarInundacion(this, ruta.slice(), pesoTotal + pesoEnlace))
      } else {
        results.push(void 0)
      }
    }
    return results
  }

  /**
   * Processes the flooding from an origin node.
   *
   * @param {NodoFlooding} nodoOrigen - The origin node initiating the flood.
   * @param {Array} ruta - The current route taken.
   * @param {number} pesoTotal - The total weight of the current route.
   */
  procesarInundacion(nodoOrigen, ruta, pesoTotal) {
    var i, len, neighborNode, pesoEnlace, ref, results
    if (ruta.includes(this)) {
      return
    }
    ruta.push(this)
    if (!this.routeMap.has(nodoOrigen.name)) {
      this.routeMap.set(nodoOrigen.name, [])
    }
    this.routeMap.get(nodoOrigen.name).push({
      ruta: ruta.slice(),
      pesoTotal
    })
    ref = this.adjacentNodes
    results = []
    for (i = 0, len = ref.length; i < len; i++) {
      ({
        Node: neighborNode,
        Peso: pesoEnlace
      } = ref[i])
      if (!ruta.includes(neighborNode)) {
        results.push(neighborNode.procesarInundacion(nodoOrigen, ruta.slice(), pesoTotal + pesoEnlace))
      } else {
        results.push(void 0)
      }
    }
    return results
  }

  /**
   * Adds an adjacent node with a specified link weight.
   *
   * @param {NodoFlooding} nodoVecino - The adjacent node.
   * @param {number} pesoEnlace - The weight of the link to the adjacent node.
   */
  agregarAdyacente(nodoVecino, pesoEnlace) {
    return this.adjacentNodes.push({
      Node: nodoVecino,
      Peso: pesoEnlace
    })
  }

  /**
   * Finds the optimal route from an origin node to this node.
   *
   * @param {string} nodoOrigen - The origin node's name.
   * @returns {Object|null} - The optimal route object or null if not found.
   */
  rutaOptima(nodoOrigen) {
    if (!this.routeMap.has(nodoOrigen)) {
      return null
    }
    return this.routeMap.get(nodoOrigen).reduce(function (optima, actual) {
      if (optima === null) {
        return actual
      }
      if (actual.pesoTotal < optima.pesoTotal) {
        return actual
      } else {
        return optima
      }
    }, null)
  }

  /**
   * Returns a string representation of the flooding node.
   *
   * @returns {string} - The string representation of the node.
   */
  toString() {
    return `NodoFlooding(${this.name})`
  }

  /**
   * Prints all routes to the console for debugging and visualization purposes.
   */
  imprimirRutas() {
    return this.routeMap.forEach((rutas, nodoOrigen) => {
      var i, len, pesoTotal, results, ruta
      console.log(`Rutas desde ${nodoOrigen} hacia ${this.name}:`)
      results = []
      for (i = 0, len = rutas.length; i < len; i++) {
        ({ ruta, pesoTotal } = rutas[i])
        results.push(console.log(`  Ruta: ${ruta.map(function (nodo) {
          return nodo.name
        }).join(' -> ')}, Peso Total: ${pesoTotal}`))
      }
      return results
    })
  }

}

export {
  NodoFlooding
}
